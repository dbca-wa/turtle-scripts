---
title: "Turtle nesting effort"
author: "Florian Mayer, Dept Parks & Wildlife WA"
date: "01/03/2017"
output: html_document
---

```{r r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("~/projects/turtle-scripts/wastd")
if (file.exists("../config/setup.R")) source("../config/setup.R")
if (file.exists("../config/load.R")) source("../config/load.R")
```

# Data

## Tracks and nests

* Tracks were recorded on Android tablets using digital data capture software ODK Collect
* Forms "TrackCount 0.10" (Nov-Dec 2016), "Track or Treat 0.26" (Feb 2017) and v0.31 (Feb 2017)
* Data warehouse ODK Aggregate at [dpaw-data.appspot.com](https://dpaw-data.appspot.com/)
* Data exported (through GUI) from dpaw-data as JSON and ingested (scripted) into
  [WAStD](https://strandings.dpaw.wa.gov.au/) after each field trip
  
## Tagging of nesting turtles

* Nesting turtles recorded on paper data sheets, entered and QA'd in WAMTRAM
* Data exported from WAMTRAM master db (scripted) into CSV and saved to 
  internal data catalogue
* Data ingested (scripted) from CSV into WAStD

### Loading data from the WAStD API
Using some [api tricks](https://www.rstudio.com/resources/videos/using-web-apis-from-r/),
a wrapper function `wastd_api` encapsulates the WAStD API:

* From a given serializer name (e.g. `animal-encounters` for taggings or 
  `turtle-nest-encounters` for tracks and nests) and some sensible defaults, 
  the API call is constructed and executed.
* On successful completion (which, depending on result size can take a while),
  the response is decoded, an informative message is printed, and the nested JSON 
  structure is flattened into a data.table.

```{r api}
# conn <- vdbConn("vdb", name = "trelliscopedb")

#' Return GeoJSON features from a WAStD API endpoint as data.table
wastd_api <- function(serializer_name, 
                      base_url="https://strandings.dpaw.wa.gov.au/api/1/",
                      query=list(taxon="Cheloniidae", limit=10000, format="json"),
                      wastd_api_token=Sys.getenv("WASTD_APITOKEN")){
  res <- GET(paste0(base_url, serializer_name), query = query, 
             add_headers(c(Authorization = wastd_api_token))) %>% stop_for_status()
  text <- content(res, as = "text", encoding = "UTF-8")
  if (identical(text, "")) stop("The response did not return any content.")
  out <- fromJSON(text, flatten = T)$features
  message(paste(nrow(out), serializer_name, "loaded from WAStD API on", res$headers$date))
  out
} 

#' Return GeoJSON features from a WAStD API endpoint as JSON
wastd_api_json <- function(serializer_name, 
                      base_url="https://strandings.dpaw.wa.gov.au/api/1/",
                      query=list(taxon="Cheloniidae", limit=10000, format="json"),
                      wastd_api_token=Sys.getenv("WASTD_APITOKEN")){
  res <- GET(paste0(base_url, serializer_name), query = query, 
             add_headers(c(Authorization = wastd_api_token))) %>% stop_for_status()
  text <- content(res, as = "text", encoding = "UTF-8")
  text
  if (identical(text, "")) stop("The response did not return any content.")
  out <- fromJSON(text, simplifyVector = FALSE)$features
  message(paste(length(out), serializer_name, "loaded from WAStD API on", res$headers$date))
  out
}

track_records <- wastd_api("turtle-nest-encounters")
tag_records <- wastd_api("animal-encounters")

nest_json <- wastd_api_json("turtle-nest-encounters", 
                             query=list(taxon="Cheloniidae", 
                                        limit=10000, 
                                        format="json", 
                                        nest_type="hatched-nest"))
# listviewer::jsonedit(nest_json)
```

### Formatting the API response
Using [purrr magic](https://www.rstudio.com/resources/videos/happy-r-users-purrr/)

* data types are parsed into native types (e.g. dates and numbers),
* records are filtered to a location (THV) and date range (from Dec 20), and
* the resulting R objects are saved locally to form a restore point.

```{r data_munging}
#' Return a UTC HTTP date as GMT+08
utc_as_gmt08 <- . %>% 
  parse_date_time(orders = c("YmdHMSz", "adbYHMS")) %>% 
  with_tz(tzone="Australia/Perth")

#' Calculate the "turtle date" from a given datetime
turtle_date <- . %>% utc_as_gmt08 %>% -hours(12) %>% as_date

#' Filter a data.frame to records collected at THV after 19 Dec 2016
#' TODO replace with filtering for THV 2016/2017 field trips at API
thv_filter <- . %>% filter(
    latitude < -21.44,
    latitude > -21.47,
    longitude > 114.96,
    longitude < 115.03,
    date > dmy("17/11/2016"))

# Flatten nested JSON, parse field formats and rename columns
tracks <- track_records %>% 
  mutate(
    datetime = properties.when %>% utc_as_gmt08,
    longitude = properties.longitude %>% as.numeric,
    latitude = properties.latitude %>% as.numeric,
    date = properties.when %>% turtle_date,
    species = properties.species,
    nest_age = properties.nest_age,
    nest_type = properties.nest_type
  ) %>% thv_filter
save(tracks, file = "data/tracks.Rda")
load("data/tracks.Rda")

tags <- tag_records %>% 
  mutate(
    datetime = properties.when %>% utc_as_gmt08,
    longitude = properties.longitude %>% as.numeric,
    latitude = properties.latitude %>% as.numeric,
    date = properties.when %>% turtle_date,
    species = properties.species,
    health = properties.health,
    nesting = properties.nesting_event,
    name=properties.name
  ) %>% thv_filter
save(tags, file = "data/tags.Rda")
load("data/tags.Rda")

# nests <- nest_json %>% {
#   tibble(
#     datetime = map_chr(., c("properties", "when")) %>% utc_as_gmt08,
#     longitude = map_dbl(., c("properties", "longitude")),
#     latitude = map_dbl(., c("properties", "latitude")),
#     turtle_date = map_chr(., c("properties", "when")) %>% turtle_date,
#     species = map_chr(., c("properties", "species"))  
#     # TODO: get properties.observation_set.observation_name=="turtlenestobservation".hatching_success
#     )
# }

nests <- tracks %>% filter(nest_type == "hatched-nest") %>% 
  filter(lengths(properties.observation_set) > 0)
# %>% map(str_detect, "emergence_success")
```

* Track observations span **`r min(tracks$datetime)` - `r max(tracks$datetime)`"**
* Tag observations span **`r min(tags$datetime)` - `r max(tags$datetime)`**

### Turtle dates
The column `date` is the reconstructed event date, as opposed to the `datetime`
of the encounter as seen by the observer.

For tagged nesting turtles:

* Assume nesting turtles are recorded between sunset and sunrise
* "turtle tagged 18 Dec 2016 22:15" = "emergence_date 18 Dec 2016"
* "turtle tagged 19 Dec 2016 02:13" = "emergence_date 18 Dec 2016"
* Count as nesting success (assuming all encounters are tagging after nesting)

For fresh tracks ("made last night"): 

* Assume tracks are recorded "the morning after" and before noon
* "fresh track recorded 19 Dec 2016 06:23" = "emergence_date 18 Dec 2016"
* Count as nesting success if nest was found.

For old tracks ("older than from last night"): 

* discard observations
* We do not check for nests on old tracks, so nesting success is "unknown" and 
  analysed as "not successful"
* Nests without clear tracks are recorded as "nest"

All dates are calculated as the calendar date (year, month, day) 12 hours before
the obesrvation's datetime. This subtracts one day from the date of all 
observations made between midnight and noon (mornings), and preserves the data of all
observations made between noon and midnight (afternoons).

All subsequent analyses bin the data by this reconstructed nesting event date.

## A first look at the data
### Interactive datatable: Tracks

```{r dt_tracks}
DT::datatable(tracks)
```

### Interactive datatable: Nesting turtles

```{r dt_tags}
DT::datatable(tags)
```


### Interactive map
Hover-scroll to zoom, click features to inspect. Hold mouse outside map to scroll page.

Be patient when scrolling, your browser is earning its salary right now.
```{r map}
grd = readOGR("thv_grid.geojson", "OGRGeoJSON")

leaflet(tracks) %>% 
  addProviderTiles("Esri.WorldImagery", group = "Aerial") %>%
  addProviderTiles("OpenStreetMap.Mapnik", group = "Place names") %>%
  setView(lng=115.0, lat=-21.45, zoom=12) %>%
  addPolygons(data = grd, weight = 1, color = "orange", opacity = 0.5, 
              label = ~paste(id), group = "Grid") %>%
  addAwesomeMarkers(~longitude, ~latitude,
                    # data = filter(tracks19, nest_type != "hatched-nest"), 
                    data=tracks, label = ~species,
                    icon = makeAwesomeIcon(icon = "home", markerColor = "green"),
                    popup = ~paste(nest_age, species, nest_type, datetime),
                    group = "Tracks") %>%
  addAwesomeMarkers(~longitude, ~latitude, data = tags, label = ~paste(name, date),
                    icon = makeAwesomeIcon(icon = "tag", markerColor = "blue"),
                    popup = ~paste(name, datetime, species, "nesting:", nesting),
                    group = "Tags") %>%
  # addAwesomeMarkers(~longitude, ~latitude,
  #                   data = nests, label = ~species,
  #                   icon = makeAwesomeIcon(icon = "home", markerColor = "yellow"),
  #                   popup = ~paste(nest_age, species, nest_type, datetime),
  #                   group = "Nests") %>%
  addLayersControl(baseGroups = c("Aerial", "Place names"),
                   overlayGroups = c("Grid", "Tracks", "Nests", "Tags"))


```

## Nesting history
```{r}
ggplot(data=tags, aes(x=date, y=name, color=nesting)) + 
  geom_point() + 
  geom_line() +
  ggtitle("Nesting history of tagged turtles") + 
  labs(x="Date", y ="Primary flipper tag label") +
  ggsave(file="data/nesting_history.pdf", height = 20, width =7)
```
# Nesting effort
To visualise and analyse nesting effort, data from track counts is combined with
data from tagging and missed turtles. 
Location and species are shared, while track / nest type (from track count) and
turtle nesting (from tagging) are combined into one column.

The column `date` is the "turtle date".

```{r nesting_encounters}
nesting_encounters <- bind_rows(
  tracks %>% 
    filter(nest_age == "fresh") %>% 
    transmute(latitude = latitude, 
              longitude = longitude, 
              date = date, 
              species = species, 
              type = nest_type),
  tags %>% 
    transmute(latitude = latitude, 
              longitude = longitude, 
              date = date, 
              species = species, 
              type = nesting)
  ) %>%
  mutate(
    diffdate=difftime(date, origin)
  )
```

### Species profiles
Observations have to be summarised into spatial (rectangular grid cells) and 
temporal (days) units and pivoted into species profiles.

Here, a rectangular grid (roughly 100 x 100m) enclosing the study area was 
artificially created. The extent and rectangular shape of the grid has no link 
to the actual study site (the beaches of Thevenard Island), and was chosen solely
for convenience. A grid too narrow will introduce false similarity through 
shared absences, while a grid too wide will lose spatial detail.

It is to be decided whether the actual nesting beaches, gridded into equidistant
sections, would be a more appropriate spatial unit.

Turn nesting encounters into a SpatialPointsDataFrame (SPDF, R's "Shapefile"), 
then spatially join this SPDF to the grid cells the encounter lies in.
Only the grid cells over sandy beaches will contain encounters.

There may be a [tidier](https://github.com/tidyverse/ggplot2/wiki/plotting-polygon-shapefiles)
way of manipulating and displaying spatial data using `ggplot2`.

```{r make_spdf}
wgs84 = CRS('+proj=longlat +datum=WGS84 +no_defs')
d.sp <- SpatialPoints(coords = select(nesting_encounters, longitude, latitude), proj4string = wgs84)
d.spdf <- SpatialPointsDataFrame(d.sp, data = nesting_encounters, proj4string = wgs84)
d.spdf.grd <- spCbind(d.spdf, over(d.spdf, grd))
# qplot(longitude, latitude, data = d.spdf.grd@data, facets = ~species, color=date)
```

## Nesting effort by species
Nesting encounters are tallied by date, species and type.
```{r plot_nesting_type_by_date}
nesting_type_by_date <- nesting_encounters %>%
  group_by(date, species, type) %>% tally(sort=F) %>% ungroup() %>%
  rename(all=n)

ggplot(nesting_type_by_date, aes(x=date, y=all, colour=type)) + 
  geom_point() + 
  facet_wrap("species", ncol=1) + 
  ggsave("data/nesting_type_by_date.pdf")
```

Nesting success is calculated as the ratio of tallied successful over total
nesting encounters per date and species. 
This combines nesting over the whole area for each surveyed day.

As successful nesting events are counted (this is negotiable):

* fresh tracks with nests (`successful-crawl`),
* hatched nests,
* tagged turtles with nesting `present`.

```{r plot_nesting_abundance}
all_nesting_by_date <- nesting_encounters %>%
  group_by(date, species) %>% tally() %>% ungroup() %>% rename(all=n)

successful_nesting_by_date <- nesting_encounters %>% 
  filter(type == 'successful-crawl' | type == "hatched-nest" | type == "present") %>%
  group_by(date, species) %>% tally() %>% ungroup() %>%
  mutate(n = ifelse(is.na(n), 0, n)) %>%
  transmute(date=date, species=species, successful=n)

# Join nesting emergences with nesting success or 0
nesting_success <- all_nesting_by_date %>%
  left_join(successful_nesting_by_date, by=c('date','species')) %>%
  mutate(nesting_success=successful/all)

ggplot(nesting_success, aes(x=date)) +
  geom_bar(aes(y=all), stat="identity", color="black", fill="black") +
  geom_bar(aes(y=successful), stat="identity", color="green", fill="green") +
  ggtitle("Nesting effort at Thevenard Island") +
  labs(x="Date", y="Number of all and successful nesting emergences") +
  facet_wrap("species", ncol=1) +
  ggsave(file="data/nesting_abundance.pdf", width=7, height=7)
```


```{r plot_nesting_success}
ggplot(nesting_success, aes(x=date, y=nesting_success)) +
  ggtitle("Nesting success at Thevenard Is") +
  geom_bar(stat="identity") +
  labs(x="Date", y ="Success rate of nesting emergences") +
  facet_wrap("species", ncol = 1) +
  ggsave("data/nesting_success.pdf", width=7, height=7)
```

```{r, eval=F}
# # Trelliscope example
# byST <- divide(nesting_success, by = c("species"))
# # byST
# timePanel <- function(x){xyplot(successful + all ~ date, 
#                                 data = x, 
#                                 auto.key = TRUE, 
#                                 ylab = "Nesting Success")}
# # timePanel(byST[[2]]$value)
# makeDisplay(byST,
#    name = "nesting_success",
#    desc = "Nesting success",
#    panelFn = timePanel,
#    cogFn = NULL,
#    width = 400, height = 400,
#    lims = list(x = "same"))
# view()
```
**Note** Track and nest counts within the tagging sector (Jetty to Chevron) 
from the night of 20/11/2016 to 21/11/2016 were not recorded
in the ODK Collect app the morning after, as wind and foot traffic during the night
rendered the tracks unreadable. The tracks and nests were recorded on paper data
sheets and will turn up in the tagging database WAMTRAM2.

November 20-22 were windy, and tracks on the south side of the western end were
likely blown over. This will result in false absence of tracks on 20/11/2016-22/11/2016.
Wind conditions after 22/11/2016 are unknown and may also decrease the number of 
detected tracks.

No track count survey on morning of 2016-11-25. Track count on 2016-11-26 
(turtle date 2016-11-25) artificially inflated track numbers by counting all 
tracks as "fresh", including tracks from non-surveyed day before. 
It would be accetable to split tracks from turtle date 2016-11-25 across turtle 
dates 2016-11-25 and 2016-11-24.

**TODO** 

* Identify periods of artificially low track count from field diary and highlight
  in figures.
* Enter surveys into WAStD, annotate with observations on weather, methodology,
  any known biases on recorded data.
* Insert here comments from expedition and surveys.


## Modelling the nesting seasons
This section aims to determine beginning, peak, and end of nesting season per 
species at the given location.

**TODO** This section is currently under construction.

## Spatial and temporal patterns of abundance
This section conducts a PCNM analysis to detect spatial and temporal patterns
in the observed abundance.

Create species profiles for species track abundance per grid cell id and encounter date.
```{r dt_species_profiles}
species_profiles <- d.spdf.grd@data %>% 
  filter(!is.na(id)) %>%
  group_by(diffdate, date, id, species) %>% 
  tally(sort=F) %>% 
  ungroup() %>%
  spread(species, n, fill=0) %>% left_join(grd, by="id", copy=T) %>%
  set_colnames(make.names(colnames(.x)))

DT::datatable(species_profiles)
```

Separate the species profile data into 

* initial responding data Y.in (nesting event tallies per species), and
* point coordinates of each grid cell X.coords.

These data frames have one row per surveyed combination of grid cell and date.

Listing only grid cells with encounters, Xs contain the coordinates, Xs.id contain
coordinates plus grid cell ID.
Both Xs and Xs.id have one row per grid cell with encounters.

Lastly, Xt lists all unique surveyed turtle dates as days since 1970, a numerical
value as required by spatial analysis tools which cannot parse comlex data types 
such as  dates.

```{r split_species_profiles}
Y.in <- species_profiles %>% 
  dplyr::select(-id, -diffdate, -date, -xmin, -xmax, -ymin, -ymax)

X.coords <- species_profiles %>% dplyr::select(xmin, ymin)

Xs.id <- grd@data %>% 
  filter(id %in% unique(species_profiles$id)) %>% 
  dplyr::select(id, xmin, ymin)
Xs <- Xs.id %>% dplyr::select(-id)
plot(Xs)

Xt <- unique(species_profiles$diffdate) %>% tbl_df()
colnames(Xt) <- "diffdate"
```

Now we can summarise all nesting events (successful and non-successful) over the
whole season (all observed dates) and plot by species.

```{r plot_nesting_distribution}
site_summary <- d.spdf.grd@data %>% 
  filter(!is.na(id)) %>%
  group_by(id, species) %>% 
  tally(sort=F) %>% 
  ungroup() %>%
  left_join(Xs.id,by = "id")

ggplot(site_summary, aes(xmin, ymin, z=n)) + 
  facet_wrap("species") + 
  geom_density2d(color="grey") + 
  geom_raster(aes(fill=n)) +
  scale_fill_gradientn(colours=c("blue","green","yellow","orange","red")) +
  ggtitle("Observed nesting events over whole season") + 
  labs(x="Longitude", y="Latitude") + 
  ggsave(file="data/nesting_distribution_all_time.pdf", width=7, height=5)
```
Green turtles seem to concentrate on the NW corner and avoid the SE corner,
where as Flatbacks seem to occur all around the island with a focus on the stretch
between west of the Jetty and the Chevron property on the East end.

### Correlations between variables
```{r plot_pairs_Y}
pairs(Y.in, main="Correlations between species")
```
The nesting emergence abundance between Flatbacks and Greens seem to correlate inversely.
Observations of Hawksbills and turtles with unknown species ID are sparse.

### Skewness in variables

* Histograms of Y and X will show the distribution of variable values.
* Expected: normal or uniform distribution.
* Right-skewed distributions can be log-transformed.
* Left-skewed distributions can be sqrt-transformed.
* Sparse observations should be Hellinger-transformed to reduce false similarity 
between sites through shared absence (which might be undersampling rather than 
true absence).

```{r plot_Y_abundance}
qplot(Y.in$"chelonia.mydas", 
      geom="histogram", 
      main="Abundance of Chelonia mydas", 
      xlab="Absolute abundance per grid cell",
      ylab="Count")
qplot(Y.in$"natator.depressus", 
      geom="histogram", 
      main="Abundance of Natator depressus", 
      xlab="Absolute abundance per grid cell",
      ylab="Count")
```
The two main species look a bit left-skewed and show many absences.

The Hellinger transformation will help reduce false similarity through shared absences.
This assumes sparse observations, where shared absence is due to undersampling
or low population density. The high number of nesting events may violate this assumption,
so that Hellinger transformation may not be appropriate.

Alternatively, relative abundance is calculated through division by row (site) sum.

```{r plot_Yhel}
Y.hel <- Y.in %>% decostand("hellinger")
pairs(Y.hel)
qplot(Y.hel$"chelonia.mydas", 
      geom="histogram", 
      main="Abundance of Chelonia mydas", 
      xlab="Hellinger-transformed abundance per grid cell",
      ylab="Count")
qplot(Y.hel$"natator.depressus", 
      geom="histogram", 
      main="Abundance of Natator depressus", 
      xlab="Hellinger-transformed abundance per grid cell",
      ylab="Count")

Y.tot <- Y.in %>% decostand("total", MARGIN=1) # relative abundance as % of site total count
pairs(Y.tot)
qplot(Y.tot$"chelonia.mydas", 
      geom="histogram", 
      main="Abundance of Chelonia mydas", 
      xlab="Relative abundance (% of site total) per grid cell",
      ylab="Count")
qplot(Y.tot$"natator.depressus", 
      geom="histogram", 
      main="Abundance of Chelonia mydas", 
      xlab="Relative abundance (% of site total) per grid cell",
      ylab="Count")
```

Remove linear spatial trends, lest they eat up explanatory power.

```{r plot_detrended_Y}
Y <- residuals(rda(Y.tot, X.coords))
pairs(Y)
```


### PCNM
Following [this tutorial](https://sites.ualberta.ca/~ahamann/teaching/renr690/Lab9.pdf).
```{r pcnm}
plot(Xs)
Xs.site.pcnm <- PCNM(dist(Xs))
summary(Xs.site.pcnm)
plot(Xs.site.pcnm$spanning, main="Spanning tree of sites")
Xs.site.pcnm.pos <- as.data.frame(Xs.site.pcnm$vectors)[,which(Xs.site.pcnm$Moran_I$Positive == T)]
sites_pcnm <- cbind(Xs.id, scores(Xs.site.pcnm.pos))
surveys_pcnm <- species_profiles %>% dplyr::left_join(sites_pcnm, by="id", copy=T)
Xs.scores <- dplyr::select(surveys_pcnm, starts_with("V"))

Xt.pcnm <- PCNM(dist(Xt))
summary(Xt.pcnm)
plot(Xt.pcnm$spanning, main="Spanning tree of observation dates")
Xt.pcnm.pos <- as.data.frame(Xt.pcnm$vectors)[,which(Xt.pcnm$Moran_I$Positive == T)]
dates_pcnm <- cbind(Xt, scores(Xt.pcnm.pos))
surveys_pcnm_t <- species_profiles %>% dplyr::left_join(dates_pcnm, by="diffdate", copy=T)
Xt.scores <- dplyr::select(surveys_pcnm_t, starts_with("V"))

Xs.sel <- forward.sel(Y, Xs.scores)
Xt.sel <- forward.sel(Y, Xt.scores)
XS <- Xs.scores %>% dplyr::select(Xs.sel$order)
XT <- Xt.scores %>% dplyr::select(Xt.sel$order)

Xs.sel
Xt.sel
Y.vp <- varpart(Y, ~as.matrix(XS), ~as.matrix(XT))
Y.vp
plot(Y.vp)
```

Outcome: 

* Spatial patterns explain a total of `r round(Y.vp$part$fract$Adj.R.squared[1] * 100, 2)`% of the variance.
* Temporal patterns explain a total of `r round(Y.vp$part$fract$Adj.R.squared[2] * 100, 2)`% of the variance.
* Another `r round(Y.vp$part$indfract$Adj.R.squared[2] * 100, 2)`% of the variance is co-explained by both spatial and temporal patterns.
* The remaining variation that is unexplained through spatial or temporal patterns is
  `r round(Y.vp$part$indfract$Adj.R.squared[4] * 100, 2)`%.

## Spatial patterns
```{r plot_xs_pcnm}
plot.xs <- function(nr, coords, scores, fs){
  
  fig <- ordisurf(coords, scores[,nr], bubble=3,
                  main=paste("Spatial pattern", fs[nr,2]), 
                  sub=paste("explains", round(as.numeric(fs[nr,3]), digits=3)*100, 
                            "% variance"))
  pdf(paste0("data/spatial_pattern_", nr, ".pdf"), width=6, height=6)
  fig
  dev.off()
  fig
}

lapply(seq_len(nrow(Xs.sel)), 
       plot.xs, 
       dplyr::select(sites_pcnm, xmin, ymin), 
       dplyr::select(sites_pcnm, starts_with("V")), 
       Xs.sel)
```

### Temporal patterns
```{r lot_xt_pcnm}
#' Create a scatterplot of PCNM values against dates.
#' 
#' nr: The row number of the forward.sel dataframe
#' dates: a vector of ymd dates
#' scores: a data.frame of PCNM scores
#' fs: an output data.frame of forward.sel
plot.xt <- function(nr, dates, scores, fs){
  fig <- plot(x=ymd(dates), y=scores[,nr], type="p",
              xlab="", ylab=paste("PCNM", fs[nr,2]), 
              main=paste("Temporal pattern", fs[nr,2]), 
              sub=paste("explains", round(as.numeric(fs[nr,3]), digits=3)*100, "% variance"))
  pdf(paste0("data/temporal_pattern_", nr, ".pdf"), width=6, height=6)
  fig
  dev.off()
  fig
}

# Plot all significant temporal PCNM variables.
# lapply(Xt.sel$order, plot.xt, species_profiles$date, XT, Xt.sel)
```

A spot of modelling!
```{r ordination}
XSm <- as.matrix(XS)
XTm <- as.matrix(XT)

Y.rda <- rda(Y ~ XSm + XTm)
fig <- ordiplot(Y.rda, main="Constrained ordination (RDA) all species", type="none")
points(fig, "sites", pch=21, col="red", bg="yellow")
text(fig, "species", col="blue", cex=0.9)
identify(fig, "spec")
```

# Questions

## Are there any hotspots of different species?

## Do certain species (Gn, Fb) favour certain beach aspects? 
Correct for difficulty of approach (shallow reef is hard to swim over).

## Does the tagging area cover the main nesting area?
The following figure shows nesting effort as total nesting events across space 
(x-axis) and time (y-axis).

The x-axis shows the grid cell ID of the 100x100m grid used to group encounters
into site x species profiles. The axis can be imagined as if the beach around
Thevenard were cut in one place and straightened into one line.

The y-axis shows the observation date as days since the epoch start (1970).

```{r}
dx <- species_profiles %>%
  transmute(
    grid=id,
    nd=natator.depressus,
    cm=chelonia.mydas
  ) %>%
  cbind(
    date=as.numeric(surveys_pcnm$diffdate)
  )

plot(dx)

steff_fb <- ordisurf(
  cbind(dx$grid, dx$date), dx$nd, bubble=3,
  main="Spatiotemporal nesting patterns: Natator depressus",
  xlab="Beach segment ID", ylab="Day since 1970")

steff_cm <- ordisurf(
  cbind(dx$grid, dx$date), dx$cm, bubble=3,
  main="Spatiotemporal nesting patterns: Chelonia mydas",
  sub="Total nesting effort",
  xlab="Beach segment ID", ylab="Day since 1970")


# are beach segment IDs in sequence? Make this more readable:
# p <- plot(Xs.id$xmin, Xs.id$ymin, xlab="Longitude", ylab="Latitude")
# text(Xs, labels=Xs.id$id, cex=1)
```


```{r, reset_workdir, echo=FALSE}
setwd("~/projects/turtle-scripts")
```
