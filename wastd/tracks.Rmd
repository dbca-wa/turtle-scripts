---
title: "Turtle nesting effort"
author: "Turtle Conservation Program, Dept Parks & Wildlife WA"
date: "13/03/2017"
output: html_document
---

```{r r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("~/projects/turtle-scripts/wastd")
if (file.exists("../config/setup.R")) source("../config/setup.R")
if (file.exists("../config/load.R")) source("../config/load.R")
```

# Data

### Tracks and nests

* Tracks were recorded on Android tablets using digital data capture software ODK Collect
* Forms "TrackCount 0.10" (Nov-Dec 2016), "Track or Treat 0.26" (Feb 2017) and v0.31 (Feb 2017)
* Data warehouse ODK Aggregate at [dpaw-data.appspot.com](https://dpaw-data.appspot.com/)
* Data exported (through GUI) from dpaw-data as JSON and ingested (scripted) into
  [WAStD](https://strandings.dpaw.wa.gov.au/) after each field trip
  
### Tagging of nesting turtles

* Nesting turtles recorded on paper data sheets, entered and QA'd in WAMTRAM
* Data exported from WAMTRAM master db (scripted) into CSV and saved to 
  internal data catalogue
* Data ingested (scripted) from CSV into WAStD

### Loading data from the WAStD API
Using some [api tricks](https://www.rstudio.com/resources/videos/using-web-apis-from-r/),
a wrapper function `wastd_api` encapsulates the WAStD API:

* From a given serializer name (e.g. `animal-encounters` for taggings or 
  `turtle-nest-encounters` for tracks and nests) and some sensible defaults, 
  the API call is constructed and executed.
* On successful completion (which, depending on result size can take a while),
  the response is decoded, an informative message is printed, and the nested JSON 
  structure is flattened into a data.table.

```{r api}
# conn <- vdbConn("vdb", name = "trelliscopedb")
track_records <- wastd_api("turtle-nest-encounters")
tag_records <- wastd_api("animal-encounters")
nest_json <- wastd_api("turtle-nest-encounters", 
                             query=list(taxon="Cheloniidae", 
                                        limit=10000, 
                                        format="json", 
                                        nest_type="hatched-nest"),
                            simplify=FALSE)
# listviewer::jsonedit(nest_json$content)
```

### Formatting the API response
Using [purrr magic](https://www.rstudio.com/resources/videos/happy-r-users-purrr/)

* data types are parsed into native types (e.g. dates and numbers),
* records are filtered to a location (THV) and date range (from Dec 20), and
* the resulting R objects are saved locally to form a restore point.

```{r data_munging}
#' Return a UTC HTTP date as GMT+08
utc_as_gmt08 <- . %>%
  parse_date_time(orders = c("YmdHMSz", "adbYHMS")) %>%
  with_tz(tzone="Australia/Perth")

#' Calculate the "turtle date" from a given datetime
as_turtle_date <- . %>% utc_as_gmt08 %>% -hours(12) %>% as_date

#' Filter a data.frame to records collected at THV after 19 Dec 2016
#' TODO replace with filtering for THV 2016/2017 field trips at API
thv_filter <- . %>% filter(
    latitude < -21.43,
    latitude > -21.48,
    longitude > 114.96,
    longitude < 115.05,
    date > dmy("17/11/2016"))

#' O Lord of Darkness, accept this our functional sacrifice of three days and three nights
#' From a list of unnamed lists, or the data.frame equivalent, extract a field or NA
extract_possibly <- possibly(extract, otherwise = -1)
get_f <- function(lol, field) lol %>% unlist %>% extract_possibly(field) %>% unlist %>% as.numeric

# Flatten nested JSON, parse field formats and rename columns
tracks <- track_records$content %>% 
  mutate(
    datetime = properties.when %>% utc_as_gmt08,
    longitude = properties.longitude %>% as.numeric,
    latitude = properties.latitude %>% as.numeric,
    date = properties.when %>% as_turtle_date,
    species = properties.species,
    nest_age = properties.nest_age,
    nest_type = properties.nest_type,
    obs = properties.observation_set,
    hatching_success =  obs %>% map(get_f, "hatching_success") %>% as.numeric,
    emergence_success = obs %>% map(get_f, "emergence_success") %>% as.numeric,
    clutch_size = obs %>% map(get_f, "egg_count_calculated") %>% as.numeric
  ) %>% thv_filter 
save(tracks, file = "data/tracks.Rda")
load("data/tracks.Rda")

tags <- tag_records$content %>% 
  mutate(
    datetime = properties.when %>% utc_as_gmt08,
    longitude = properties.longitude %>% as.numeric,
    latitude = properties.latitude %>% as.numeric,
    date = properties.when %>% as_turtle_date,
    species = properties.species,
    health = properties.health,
    nesting = properties.nesting_event,
    name=properties.name
  ) %>% thv_filter
save(tags, file = "data/tags.Rda")
load("data/tags.Rda")

# Hold my beer, we'll do it in JSON
nests <- nest_json$content %>% {
  tibble::tibble(
    datetime = map_chr(., c("properties", "when")) %>% utc_as_gmt08,
    longitude = map_dbl(., c("properties", "longitude")),
    latitude = map_dbl(., c("properties", "latitude")),
    date = map_chr(., c("properties", "when")) %>% as_turtle_date,
    species = map_chr(., c("properties", "species")),
    obs = map(., c("properties", "observation_set")),
    hatching_success = obs %>% map(get_f, "hatching_success") %>% as.numeric,
    emergence_success = obs %>% map(get_f, "emergence_success") %>% as.numeric,
    clutch_size = obs %>% map(get_f, "egg_count_calculated") %>% as.numeric
    )
} %>% thv_filter
save(nests, file = "data/nests.Rda")
load("data/nests.Rda")

# unique(nests$hatching_success)
# listviewer::jsonedit(nests)
```

* Track observations span **`r min(tracks$datetime)` - `r max(tracks$datetime)`"**
* Tag observations span **`r min(tags$datetime)` - `r max(tags$datetime)`**

### Turtle dates
The column `date` is the reconstructed event date, as opposed to the `datetime`
of the encounter as seen by the observer.

For tagged nesting turtles:

* Assume nesting turtles are recorded between sunset and sunrise
* "turtle tagged 18 Dec 2016 22:15" = "emergence_date 18 Dec 2016"
* "turtle tagged 19 Dec 2016 02:13" = "emergence_date 18 Dec 2016"
* Count as nesting success (assuming all encounters are tagging after nesting)

For fresh tracks ("made last night"): 

* Assume tracks are recorded "the morning after" and before noon
* "fresh track recorded 19 Dec 2016 06:23" = "emergence_date 18 Dec 2016"
* Count as nesting success if nest was found.

For old tracks ("older than from last night"): 

* discard observations
* We do not check for nests on old tracks, so nesting success is "unknown" and 
  analysed as "not successful"
* Nests without clear tracks are recorded as "nest"

All dates are calculated as the calendar date (year, month, day) 12 hours before
the obesrvation's datetime. This subtracts one day from the date of all 
observations made between midnight and noon (mornings), and preserves the data of all
observations made between noon and midnight (afternoons).

All subsequent analyses bin the data by this reconstructed nesting event date.

## A first look at the data
### Interactive datatable: Tracks

```{r dt_tracks}
DT::datatable(tracks)
```

### Interactive datatable: Nesting turtles

```{r dt_tags}
DT::datatable(tags)
```

```{r dt_nests}
DT::datatable(nests)
```


### Interactive map
Hover-scroll to zoom, click features to inspect. Hold mouse outside map to scroll page.

Be patient when scrolling, your browser is earning its salary right now.
```{r map}
grd = readOGR("thv_grid.geojson", "OGRGeoJSON")

trackIcons <- awesomeIconList(
  "cheloniidae-fam" = makeAwesomeIcon(icon='align-center', library='glyphicon', markerColor = 'black'),
  "chelonia-mydas" = makeAwesomeIcon(icon='align-center', library='glyphicon', markerColor = 'green'),
  "eretmochelys-imbricata" = makeAwesomeIcon(icon='align-center', library='glyphicon', markerColor = 'blue'),
  "natator-depressus" = makeAwesomeIcon(icon='align-center', library='glyphicon', markerColor = 'red')
  )
tagIcons <- awesomeIconList(
  "cheloniidae-fam" = makeAwesomeIcon(icon='tag', library='glyphicon', markerColor = 'black'),
  "chelonia-mydas" = makeAwesomeIcon(icon='tag', library='glyphicon', markerColor = 'green'),
  "eretmochelys-imbricata" = makeAwesomeIcon(icon='tag', library='glyphicon', markerColor = 'blue'),
  "natator-depressus" = makeAwesomeIcon(icon='tag', library='glyphicon', markerColor = 'red')
  )
nestIcons <- awesomeIconList(
  "cheloniidae-fam" = makeAwesomeIcon(icon='baby-formula', library='glyphicon', markerColor = 'black'),
  "chelonia-mydas" = makeAwesomeIcon(icon='baby-formula', library='glyphicon', markerColor = 'green'),
  "eretmochelys-imbricata" = makeAwesomeIcon(icon='baby-formula', library='glyphicon', markerColor = 'blue'),
  "natator-depressus" = makeAwesomeIcon(icon='baby-formula', library='glyphicon', markerColor = 'red')
  )

leaflet(tracks) %>% 
  addProviderTiles("Esri.WorldImagery", group = "Aerial") %>%
  addProviderTiles("OpenStreetMap.Mapnik", group = "Place names") %>%
  setView(lng=115.0, lat=-21.45, zoom=12) %>%
  addPolygons(data = grd, weight = 1, color = "orange", opacity = 0.5, 
              label = ~paste(id), group = "Grid") %>%
  addAwesomeMarkers(~longitude, ~latitude,
                    data = filter(tracks, nest_type != "hatched-nest"), 
                    # data=tracks, 
                    icon = ~trackIcons[species],
                    label = ~paste("Track", date, nest_age, species, nest_type),
                    popup = ~paste("Track", date, nest_age, species, nest_type),
                    group = "Tracks") %>%
  addAwesomeMarkers(~longitude, ~latitude, data = tags,
                    icon = ~tagIcons[species],
                    label = ~paste("Tag", date, species, name, "nesting:", nesting),
                    popup = ~paste("Tag", date, species, name, "nesting:", nesting),
                    group = "Tags") %>%
  # addHeatmap(data=tags, lng = ~longitude, lat = ~latitude, 
  #            blur = 20, max = 1, radius = 15) %>%
  addAwesomeMarkers(~longitude, ~latitude,
                    data = nests,
                    icon = ~nestIcons[species],
                    label = ~paste("Nest", date, species, "HS", as.numeric(hatching_success), "%, ES", as.numeric(emergence_success), "%"),
                    popup = ~paste("Nest", date, species, "HS", as.numeric(hatching_success), "%, ES", as.numeric(emergence_success), "%"),
                    group = "Nests") %>%
  addLayersControl(baseGroups = c("Aerial", "Place names"),
                   overlayGroups = c("Grid", "Tracks", "Tags", "Nests"))


```

# Tagging
A total of `r nrow(tags)` turtles were processed (captured new or resighted) in total. 
This number excludes records in WAMTRAM with missing coordinates or time stamps. 
Re-sightings are counted as separate handling events.

```{r}
tags_by_date <- tags %>% group_by(date) %>% tally() %>% ungroup()
animals_by_date <- tags %>% group_by(date, name) %>% tally() %>% ungroup()
```

On average, `r mean(tags_by_date$n)` turtles were processed per surveyed day.

```{r}
datatable(tags_by_date, caption="Number of turtles handled per day")
```
```{r}
datatable(animals_by_date, caption="Number of individual turtles handled per day")
```


```{r fig_turtles_processed_per_day}
datatable(tags_by_date)
ggplot(tags_by_date, aes(x=date, y=n)) + geom_bar(stat="identity") +
  ggtitle("Turtles processed per day") + theme_minimal()
```


## Nesting history
```{r, fig.width=7,fig.height=20}
ggplot(data=tags, aes(x=date, y=name, color=nesting)) + 
  geom_point() + 
  geom_line() +
  ggtitle("Nesting history of tagged turtles") + 
  labs(x="Date", y ="Primary flipper tag label") +
  theme_minimal() +
  ggsave(file="data/nesting_history.pdf", height = 20, width =7)
```
## Questions to tagging data

* How many days to first resighting?
* (Sabrina to add)




# Hatching success
From `r nrow(filter(nests, hatching_success>=0))` conclusive nest excavations,
the calculated hatching and emergence success are shown summarised per day.

```{r}
nests_with_hs <- filter(nests, hatching_success>=0, species=="natator-depressus")
ggplot(nests_with_hs) + 
  geom_boxplot(aes(group=date, x=date, y=as.numeric(hatching_success)), na.rm=TRUE, show.legend=TRUE, color="black") +
  geom_boxplot(aes(group=date, x=date, y=as.numeric(emergence_success)), na.rm=TRUE, show.legend=TRUE, color="gray") +
  ggtitle("Flatback hatching (black) and emergence (grey) success") +
  xlab("Date") + ylab("Success rate in percent") + theme_minimal()
```

TODO

* The mean, SD and range for HS and ES and clutch size per species.
* Frequency distribution of hatching success per species as 
  proportion of nests (% of total) over hatching success binned into 10% buckets.
* Heatmap / marker points of hatching success. Bin or grade clutch size into colour.



# Turtle tracks

TODO

* No days surveyed: `r length(unique(tracks$date))`
* Table, per species (rows): 
  Total number of tracks, 
  mean number of tracks per day, 
  min and max number of tracks per day (cols),
  total nesting success as number of tracks with nest / all tracks,
  mean clutch size from excavated nests

```{r}
tracks_by_species <- tracks %>% filter(nest_age=="fresh") %>% group_by(species, date) %>% tally() %>% group_by(species) %>% dplyr::summarize("mean"=mean(n))
## TODO
datatable(tracks_by_species)
```


# Nesting effort
To visualise and analyse nesting effort, data from track counts is combined with
data from tagging and missed turtles. 
Location and species are shared, while track / nest type (from track count) and
turtle nesting (from tagging) are combined into one column.

The column `date` is the "turtle date".

```{r nesting_encounters}
nesting_encounters <- bind_rows(
  tracks %>% 
    filter(nest_age == "fresh") %>% 
    transmute(latitude = latitude, 
              longitude = longitude, 
              date = date, 
              species = species, 
              type = nest_type),
  tags %>% 
    transmute(latitude = latitude, 
              longitude = longitude, 
              date = date, 
              species = species, 
              type = nesting)
  ) %>%
  mutate(
    diffdate=difftime(date, origin)
  )
```

### Species profiles
Observations have to be summarised into spatial (rectangular grid cells) and 
temporal (days) units and pivoted into species profiles.

Here, a rectangular grid (roughly 100 x 100m) enclosing the study area was 
artificially created. The extent and rectangular shape of the grid has no link 
to the actual study site (the beaches of Thevenard Island), and was chosen solely
for convenience. A grid too narrow will introduce false similarity through 
shared absences, while a grid too wide will lose spatial detail.

It is to be decided whether the actual nesting beaches, gridded into equidistant
sections, would be a more appropriate spatial unit.

Turn nesting encounters into a SpatialPointsDataFrame (SPDF, R's "Shapefile"), 
then spatially join this SPDF to the grid cells the encounter lies in.
Only the grid cells over sandy beaches will contain encounters.

There may be a [tidier](https://github.com/tidyverse/ggplot2/wiki/plotting-polygon-shapefiles)
way of manipulating and displaying spatial data using `ggplot2`.

```{r make_spdf}
wgs84 = CRS('+proj=longlat +datum=WGS84 +no_defs')
d.sp <- SpatialPoints(coords = select(nesting_encounters, longitude, latitude), proj4string = wgs84)
d.spdf <- SpatialPointsDataFrame(d.sp, data = nesting_encounters, proj4string = wgs84)
d.spdf.grd <- spCbind(d.spdf, over(d.spdf, grd))
# qplot(longitude, latitude, data = d.spdf.grd@data, facets = ~species, color=date)
```

## Nesting effort by species
Nesting encounters are tallied by date, species and type.
```{r plot_nesting_type_by_date}
nesting_type_by_date <- nesting_encounters %>%
  group_by(date, species, type) %>% tally(sort=F) %>% ungroup() %>% rename(all=n)

ggplot(nesting_type_by_date, aes(x=date, y=all, colour=type)) + 
  geom_point() + 
  facet_wrap("species", ncol=1) + 
  ggsave("data/nesting_type_by_date.pdf")
```

Nesting success is calculated as the ratio of tallied successful over total
nesting encounters per date and species. 
This combines nesting over the whole area for each surveyed day.

As successful nesting events are counted (this is negotiable):

* fresh tracks with nests (`successful-crawl`),
* hatched nests,
* tagged turtles with nesting `present`.

```{r plot_nesting_abundance}
all_nesting_by_date <- nesting_encounters %>%
  group_by(date, species) %>% tally() %>% ungroup() %>% rename(all=n)

successful_nesting_by_date <- nesting_encounters %>% 
  filter(type == 'successful-crawl' | type == "present") %>%
  group_by(date, species) %>% tally() %>% ungroup() %>%
  mutate(n = ifelse(is.na(n), 0, n)) %>%
  transmute(date=date, species=species, successful=n)

# Join nesting emergences with nesting success or 0
nesting_success <- all_nesting_by_date %>%
  left_join(successful_nesting_by_date, by=c('date','species')) %>%
  mutate(nesting_success=successful/all)

ggplot(nesting_success, aes(x=date)) +
  geom_bar(aes(y=all), stat="identity", color="black", fill="black") +
  geom_bar(aes(y=successful), stat="identity", color="green", fill="green") +
  ggtitle("Nesting effort at Thevenard Island", 
          subtitle="Green: tracks with nest, hatched nests, nesting turtles\nBlack: all nesting") +
  labs(x="Date", y="Number of all and successful nesting emergences") +
  facet_wrap("species", ncol=1) +
  ggsave(file="data/nesting_abundance.pdf", width=7, height=7)
```

TODO: above figure from only fresh tracks with successful = "successful-crawl" and all, one figure per species
TODO: fit GAM

```{r plot_nesting_success}
ggplot(nesting_success, aes(x=date, y=nesting_success)) +
  ggtitle("Nesting success at Thevenard Is") +
  geom_bar(stat="identity") +
  labs(x="Date", y ="Success rate of nesting events") +
  facet_wrap("species", ncol = 1) +
  ggsave("data/nesting_success.pdf", width=7, height=7)
```

```{r, eval=F}
# # Trelliscope example
# byST <- divide(nesting_success, by = c("species"))
# # byST
# timePanel <- function(x){xyplot(successful + all ~ date, 
#                                 data = x, 
#                                 auto.key = TRUE, 
#                                 ylab = "Nesting Success")}
# # timePanel(byST[[2]]$value)
# makeDisplay(byST,
#    name = "nesting_success",
#    desc = "Nesting success",
#    panelFn = timePanel,
#    cogFn = NULL,
#    width = 400, height = 400,
#    lims = list(x = "same"))
# view()
```
**Note** Track and nest counts within the tagging sector (Jetty to Chevron) 
from the night of 20/11/2016 to 21/11/2016 were not recorded
in the ODK Collect app the morning after, as wind and foot traffic during the night
rendered the tracks unreadable. The tracks and nests were recorded on paper data
sheets and will turn up in the tagging database WAMTRAM2.

November 20-22 were windy, and tracks on the south side of the western end were
likely blown over. This will result in false absence of tracks on 20/11/2016-22/11/2016.
Wind conditions after 22/11/2016 are unknown and may also decrease the number of 
detected tracks.

No track count survey on morning of 2016-11-25. Track count on 2016-11-26 
(turtle date 2016-11-25) artificially inflated track numbers by counting all 
tracks as "fresh", including tracks from non-surveyed day before. 
It would be accetable to split tracks from turtle date 2016-11-25 across turtle 
dates 2016-11-25 and 2016-11-24.

**TODO** 

* Identify periods of artificially low track count from field diary and highlight
  in figures.
* Enter surveys into WAStD, annotate with observations on weather, methodology,
  any known biases on recorded data.
* Insert here comments from expedition and surveys.


## Modelling the nesting seasons
This section aims to determine beginning, peak, and end of nesting season per 
species at the given location.

**TODO** This section is currently under construction.

## Spatial and temporal patterns of abundance
This section conducts a PCNM analysis to detect spatial and temporal patterns
in the observed abundance.

Create species profiles for species track abundance per grid cell id and encounter date.
```{r dt_species_profiles}
species_profiles <- d.spdf.grd@data %>% 
  filter(!is.na(id)) %>%
  group_by(diffdate, date, id, species) %>% 
  tally(sort=F) %>% 
  ungroup() %>%
  spread(species, n, fill=0) %>% left_join(grd, by="id", copy=T) %>%
  set_colnames(make.names(colnames(.)))

DT::datatable(species_profiles)
```

Separate the species profile data into 

* initial responding data Y.in (nesting event tallies per species), and
* point coordinates of each grid cell X.coords.

These data frames have one row per surveyed combination of grid cell and date.

Listing only grid cells with encounters, Xs contain the coordinates, Xs.id contain
coordinates plus grid cell ID.
Both Xs and Xs.id have one row per grid cell with encounters.

Lastly, Xt lists all unique surveyed turtle dates as days since 1970, a numerical
value as required by spatial analysis tools which cannot parse comlex data types 
such as  dates.

```{r split_species_profiles}
Y.in <- species_profiles %>% 
  dplyr::select(-id, -diffdate, -date, -xmin, -xmax, -ymin, -ymax)

X.coords <- species_profiles %>% dplyr::select(xmin, ymin)

Xs.id <- grd@data %>% 
  filter(id %in% unique(species_profiles$id)) %>% 
  dplyr::select(id, xmin, ymin)
Xs <- Xs.id %>% dplyr::select(-id)
plot(Xs)

Xt <- unique(species_profiles$diffdate) %>% tbl_df()
colnames(Xt) <- "diffdate"
```

Now we can summarise all nesting events (successful and non-successful) over the
whole season (all observed dates) and plot by species.

```{r plot_nesting_distribution}
site_summary <- d.spdf.grd@data %>% 
  filter(!is.na(id)) %>%
  group_by(id, species) %>% 
  tally(sort=F) %>% 
  ungroup() %>%
  left_join(Xs.id,by = "id")

ggplot(site_summary, aes(xmin, ymin, z=n)) + 
  facet_wrap("species") + 
  geom_density2d(color="grey") + 
  geom_raster(aes(fill=n)) +
  scale_fill_gradientn(colours=c("blue","green","yellow","orange","red")) +
  ggtitle("Observed nesting events over whole season") + 
  labs(x="Longitude", y="Latitude") + 
  ggsave(file="data/nesting_distribution_all_time.pdf", width=7, height=5)
```

Green turtles seem to concentrate on the NW corner and avoid the SE corner,
where as Flatbacks seem to occur all around the island with a focus on the stretch
between west of the Jetty and the Chevron property on the East end.

TODO 
* split up by species, one figure per species, show only FB  and GN, overlay over THV aerial imagery
* same for only successful tracks ("successful-crawl") and tags (nesting "present")
* same for only unsuccessful tracks ("false-crawl", "track-unsure", "track-not-assessed") and tags (nesting not "present")
* same for only successful nesting (nesting "present"), only FB
* same for only unsuccessful nesting (nesting not "present"), only FB

Are 

* Get nesting area form WAStD
* count all nesting (tracks & tags, both succ and unsuccc) inside / outside nesting area for FB

### Correlations between variables
```{r plot_pairs_Y}
pairs(Y.in, main="Correlations between species")
```
The nesting emergence abundance between Flatbacks and Greens seem to correlate inversely.
Observations of Hawksbills and turtles with unknown species ID are sparse.

### Skewness in variables

* Histograms of Y and X will show the distribution of variable values.
* Expected: normal or uniform distribution.
* Right-skewed distributions can be log-transformed.
* Left-skewed distributions can be sqrt-transformed.
* Sparse observations should be Hellinger-transformed to reduce false similarity 
between sites through shared absence (which might be undersampling rather than 
true absence).

```{r plot_Y_abundance}
qplot(Y.in$"chelonia.mydas", 
      geom="histogram", 
      main="Abundance of Chelonia mydas", 
      xlab="Absolute abundance per grid cell",
      ylab="Count")
qplot(Y.in$"natator.depressus", 
      geom="histogram", 
      main="Abundance of Natator depressus", 
      xlab="Absolute abundance per grid cell",
      ylab="Count")
```
The two main species look a bit left-skewed and show many absences.

The Hellinger transformation will help reduce false similarity through shared absences.
This assumes sparse observations, where shared absence is due to undersampling
or low population density. The high number of nesting events may violate this assumption,
so that Hellinger transformation may not be appropriate.

Alternatively, relative abundance is calculated through division by row (site) sum.

```{r plot_Yhel}
Y.hel <- Y.in %>% decostand("hellinger")
pairs(Y.hel)
qplot(Y.hel$"chelonia.mydas", 
      geom="histogram", 
      main="Abundance of Chelonia mydas", 
      xlab="Hellinger-transformed abundance per grid cell",
      ylab="Count")
qplot(Y.hel$"natator.depressus", 
      geom="histogram", 
      main="Abundance of Natator depressus", 
      xlab="Hellinger-transformed abundance per grid cell",
      ylab="Count")

Y.tot <- Y.in %>% decostand("total", MARGIN=1) # relative abundance as % of site total count
pairs(Y.tot)
qplot(Y.tot$"chelonia.mydas", 
      geom="histogram", 
      main="Abundance of Chelonia mydas", 
      xlab="Relative abundance (% of site total) per grid cell",
      ylab="Count")
qplot(Y.tot$"natator.depressus", 
      geom="histogram", 
      main="Abundance of Chelonia mydas", 
      xlab="Relative abundance (% of site total) per grid cell",
      ylab="Count")
```

Remove linear spatial trends, lest they eat up explanatory power.

```{r plot_detrended_Y}
Y <- residuals(rda(Y.tot, X.coords))
pairs(Y)
```


### PCNM
Following [this tutorial](https://sites.ualberta.ca/~ahamann/teaching/renr690/Lab9.pdf).
```{r pcnm}
plot(Xs)
Xs.site.pcnm <- PCNM(dist(Xs))
summary(Xs.site.pcnm)
plot(Xs.site.pcnm$spanning, main="Spanning tree of sites")
Xs.site.pcnm.pos <- as.data.frame(Xs.site.pcnm$vectors)[,which(Xs.site.pcnm$Moran_I$Positive == T)]
sites_pcnm <- cbind(Xs.id, scores(Xs.site.pcnm.pos))
surveys_pcnm <- species_profiles %>% dplyr::left_join(sites_pcnm, by="id", copy=T)
Xs.scores <- dplyr::select(surveys_pcnm, starts_with("V"))

Xt.pcnm <- PCNM(dist(Xt))
summary(Xt.pcnm)
plot(Xt.pcnm$spanning, main="Spanning tree of observation dates")
Xt.pcnm.pos <- as.data.frame(Xt.pcnm$vectors)[,which(Xt.pcnm$Moran_I$Positive == T)]
dates_pcnm <- cbind(Xt, scores(Xt.pcnm.pos))
surveys_pcnm_t <- species_profiles %>% dplyr::left_join(dates_pcnm, by="diffdate", copy=T)
Xt.scores <- dplyr::select(surveys_pcnm_t, starts_with("V"))

Xs.sel <- forward.sel(Y, Xs.scores)
Xt.sel <- forward.sel(Y, Xt.scores)
XS <- Xs.scores %>% dplyr::select(Xs.sel$order)
XT <- Xt.scores %>% dplyr::select(Xt.sel$order)

Xs.sel
Xt.sel
Y.vp <- varpart(Y, ~as.matrix(XS), ~as.matrix(XT))
Y.vp
plot(Y.vp)
```

Outcome: 

* Spatial patterns explain a total of `r round(Y.vp$part$fract$Adj.R.squared[1] * 100, 2)`% of the variance.
* Temporal patterns explain a total of `r round(Y.vp$part$fract$Adj.R.squared[2] * 100, 2)`% of the variance.
* Another `r round(Y.vp$part$indfract$Adj.R.squared[2] * 100, 2)`% of the variance is co-explained by both spatial and temporal patterns.
* The remaining variation that is unexplained through spatial or temporal patterns is
  `r round(Y.vp$part$indfract$Adj.R.squared[4] * 100, 2)`%.

## Spatial patterns
```{r plot_xs_pcnm}
plot.xs <- function(nr, coords, scores, fs){
  
  fig <- ordisurf(coords, scores[,nr], bubble=3,
                  main=paste("Spatial pattern", fs[nr,2]), 
                  sub=paste("explains", round(as.numeric(fs[nr,3]), digits=3)*100, 
                            "% variance"))
  pdf(paste0("data/spatial_pattern_", nr, ".pdf"), width=6, height=6)
  fig
  dev.off()
  fig
}

lapply(seq_len(nrow(Xs.sel)), 
       plot.xs, 
       dplyr::select(sites_pcnm, xmin, ymin), 
       dplyr::select(sites_pcnm, starts_with("V")), 
       Xs.sel)
```

### Temporal patterns
```{r lot_xt_pcnm}
#' Create a scatterplot of PCNM values against dates.
#' 
#' nr: The row number of the forward.sel dataframe
#' dates: a vector of ymd dates
#' scores: a data.frame of PCNM scores
#' fs: an output data.frame of forward.sel
plot.xt <- function(nr, dates, scores, fs){
  fig <- plot(x=ymd(dates), y=scores[,nr], type="p",
              xlab="", ylab=paste("PCNM", fs[nr,2]), 
              main=paste("Temporal pattern", fs[nr,2]), 
              sub=paste("explains", round(as.numeric(fs[nr,3]), digits=3)*100, "% variance"))
  pdf(paste0("data/temporal_pattern_", nr, ".pdf"), width=6, height=6)
  fig
  dev.off()
  fig
}

# Plot all significant temporal PCNM variables.
# lapply(Xt.sel$order, plot.xt, species_profiles$date, XT, Xt.sel)
```

A spot of modelling!
```{r ordination}
XSm <- as.matrix(XS)
XTm <- as.matrix(XT)

Y.rda <- rda(Y ~ XSm + XTm)
fig <- ordiplot(Y.rda, main="Constrained ordination (RDA) all species", type="none")
points(fig, "sites", pch=21, col="red", bg="yellow")
text(fig, "species", col="blue", cex=0.9)
identify(fig, "spec")
```

# Questions

## Are there any hotspots of different species?

## Do certain species (Gn, Fb) favour certain beach aspects? 
Correct for difficulty of approach (shallow reef is hard to swim over).

## Does the tagging area cover the main nesting area?
The following figure shows nesting effort as total nesting events across space 
(x-axis) and time (y-axis).

The x-axis shows the grid cell ID of the 100x100m grid used to group encounters
into site x species profiles. The axis can be imagined as if the beach around
Thevenard were cut in one place and straightened into one line.

The y-axis shows the observation date as days since the epoch start (1970).

```{r}
dx <- species_profiles %>%
  transmute(
    grid=id,
    nd=natator.depressus,
    cm=chelonia.mydas
  ) %>%
  cbind(
    date=as.numeric(surveys_pcnm$diffdate)
  )

plot(dx)

steff_fb <- ordisurf(
  cbind(dx$grid, dx$date), dx$nd, bubble=3,
  main="Spatiotemporal nesting patterns: Natator depressus",
  xlab="Beach segment ID", ylab="Day since 1970")

steff_cm <- ordisurf(
  cbind(dx$grid, dx$date), dx$cm, bubble=3,
  main="Spatiotemporal nesting patterns: Chelonia mydas",
  sub="Total nesting effort",
  xlab="Beach segment ID", ylab="Day since 1970")


# are beach segment IDs in sequence? Make this more readable:
# p <- plot(Xs.id$xmin, Xs.id$ymin, xlab="Longitude", ylab="Latitude")
# text(Xs, labels=Xs.id$id, cex=1)
```




```{r, reset_workdir, echo=FALSE}
setwd("~/projects/turtle-scripts")
```
